\chapter{Entwurf}
\section{Projektverwaltung und Werkzeuge}
\section{Build Prozess}
\subsection{CMake}
\subsection{Build unter Unix}
Zum Erstellen des Projektes OHMComm unter Unix-Systemen wird neben einem C++11-fähigen Compiler und dem Programm \textbf{CMake} noch die \textbf{Make} Build-Suite sowie eine Audio-Bibliothek mitsamt Header-Dateien benötigt. Während Make und eine Audio-Bibliothek auf den meisten Unix-Systemen bereits mitgeliefert werden, müssen die Entwicklungs-Header für die verwendete Audio-Bibliothek meist erst noch installiert werden. Als Audio-Bibliothek wird unter Linux-Systemen OSS, ALSA, Jack und PulseAudio unterstützt \cite{RTAudioAPIs}. Die Entwicklungs-Header für die Audio-Bibliotheken liegen je nach System -- oder genauer: je nach Paketverwaltungssystem -- in verschieden benannten Paketen. So heißt das Paket für die ALSA-Header unter Debian \texttt{libasound-dev} und unter Fedora \texttt{alsa-lib-devel}.
Unter Linux und den meisten Unix-Betriebssystemen wird das Projekt kompiliert, indem zuerst mit dem Befehl \texttt{cmake -G ``Unix Makefiles''} aus der CMake-Beschreibung eine \texttt{Makefile} -- also eine Anleitung für das \texttt{make} Build-System -- erstellt wird. Daraufhin können mit dem Befehl \texttt{make} im Zielverzeichnis des vorherigen Kommandos die einzelnen Bibliotheken oder Programme kompiliert werden. So erstellt \texttt{make OHMCommLib} die Bibliothek \textbf{OHmCommLib}, die in weitere Programme eingebunden werden kann (siehe Abschnitt \ref{configurationUsages}). \texttt{make OHMComm} erstellt das ausführbare Programm \textbf{OHMComm} und \texttt{make Tests} die Test-Suite für das Projekt.
\subsection{Build unter Windows}
\section{Softwarearchitektur}
\subsection{Konfiguration und Verwendung}
\label{configurationUsages}
%TODO: nach Steuerung?
OHMComm implementiert eine Vielzahl an Konfigurationsmöglichkeiten, um einen möglichst breiten Verwendungsbereich zu bieten. So kann die prototypische Anwendung aus Kapitel \ref{prototypProgram} als interaktive Konsolen-Anwendung gestartet werden. Dabei werden alle Einstellungsmöglichkeiten nacheinander ausgegeben und der Benutzer kann durch Eingabe einen der vorgeschlagenen Werte auswählen oder einen eigenen Wert eingeben, je nach Art der Einstellung.
\\
Ebenso kann die Konfiguration durch Kommandozeilen-Argumente vorgenommen werden. Hierfür benutzt OHMComm den aus Unix bekannten Syntax, bei dem Schlüssel-Werte Paare mit einem Gleichheitszeichen = getrennt angegeben werden, z.B. \texttt{--local-port=54321} für die Bestimmung des lokalen Ports. Ebenso werden für die meisten Optionen sowohl ein kurzer als auch ein langer Schlüssel unterstützt. So geben beide Argumente \texttt{-h} und \texttt{--help} die Hilfe auf der Kommandozeile aus, die alle verfügbaren Parameter und deren Bedeutung sowie Standard-Werte anzeigt. Die gleichen Parameter können auch aus einer Konfigurations-Datei geladen werden. Dafür werden dort die Schlüssel-Wert Paare zeilenweise und auch durch ein Gleichheitszeichen getrennt aufgelistet und die Datei beim Start an das OHMComm-Programm als einzigen Parameter übergeben.
\\
Um das Programm auch als Bibliothek verwenden zu können, wird eine Möglichkeit geboten, über die benötigten und optionalen Einstellungen Methodenaufrufe zu setzen. %TODO: Verwendung als Bib, Was kanns? Nutzen

TODO: Ausführlicher!?
TODO: Passive Konfiguration, Problematik, warum wird benötigt? Wie implementiert? Was wird gelöst?
\subsection{Audio-Schnittstelle}
\subsection{Verarbeitungskette}
\subsection{Austauschbarkeit und Instantiierung}
\subsection{RTP-Protokoll}
\subsubsection{RTCP-Protokoll}
\subsection{Jitter-Buffer}
TODO: Warum wird BUffer benötigt? Reordering, Loss
Wo wird Buffer verwendet? Auf Empfänger-Seite, eigentlich einen pro Sender, wir haben aber nur einen Sender
Was macht Buffer? Reihenfolge, Concealment, optional auch Auspielverzögerung, um späte Pakete noch ausspielen zu können
\subsection{Netzwerkverbindung}
TODO: Wie alle anderen Komponenten auch Impl- und Plattformunabhängig gebaut, d.h. NetworkWrapper kann in UDP und TCP (hinzugefügt in späterer version) oder z.B: auch anderen Netzwerken, verschlüsselt oder ähnlichen Implementiert werden
\section{Konkrete Softwarekomponenten}
\subsection{RTAudio}
\subsection{Opus}
\section{Statistiken}

TODO: Grund: Zum Testen der performance, berechnen algorithmisches Delay
Art: Audio-Daten/Zeit -> ``Bandbreite'' der Audio-Schnittstelle, Frames/Zeit -> tatsächliche Samplerate, Header/Daten -> Overhead, Gesendete/Empfangene/verlorene Pakete -> Verlust, Buffer-Usage -> max Abspieldelay (Playout Point), Aufgenomme/Gesendet -> Kompression, Empfangen/Abgespielt -> Dekompression,
Prozessor-Profiler: konfigurierbar, Gesamtdauer/Dauer per Schleifendurchlauf bearbeiten Input/Output-Daten -> Algorithmischer Delay je Prozessor

Statistiken werden immer auf Stdout ausgegeben + optional Statistiken in Datei Schreiben, Pfad konfiguierbar.
